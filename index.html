<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mythical Dreamscape AI</title>
    <style>
        :root {
            --primary-color: #8a2be2;
            --secondary-color: #00bfff;
            --background-color: #0f0f1f;
            --text-color: #e6e6ff;
            --accent-color: #ff69b4;
            --card-bg: rgba(30, 30, 60, 0.7);
            --border-radius: 15px;
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            min-height: 100vh;
            overflow-x: hidden;
            transition: var(--transition);
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 50%, rgba(138, 43, 226, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 191, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(255, 105, 180, 0.1) 0%, transparent 50%);
            z-index: -1;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: var(--card-bg);
            border-radius: var(--border-radius);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .logo-icon {
            font-size: 2rem;
            color: var(--accent-color);
        }

        .logo h1 {
            font-size: 1.8rem;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 10px rgba(138, 43, 226, 0.3);
        }

        .model-selector {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .model-selector label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .model-dropdown {
            background: var(--card-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius);
            padding: 8px 15px;
            color: var(--text-color);
            font-size: 0.9rem;
            cursor: pointer;
            min-width: 200px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            transition: var(--transition);
        }

        .model-dropdown:hover {
            box-shadow: 0 4px 20px rgba(138, 43, 226, 0.3);
        }

        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--card-bg);
            border-radius: var(--border-radius);
            overflow: hidden;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            max-width: 80%;
            padding: 15px;
            border-radius: 18px;
            line-height: 1.5;
            position: relative;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .user-message {
            align-self: flex-end;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border-bottom-right-radius: 5px;
        }

        .ai-message {
            align-self: flex-start;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom-left-radius: 5px;
        }

        .chat-input-container {
            display: flex;
            padding: 20px;
            gap: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chat-input {
            flex: 1;
            padding: 15px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-color);
            font-size: 1rem;
            resize: none;
            transition: var(--transition);
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(138, 43, 226, 0.2);
        }

        .send-button {
            padding: 15px 25px;
            border-radius: var(--border-radius);
            border: none;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .send-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(138, 43, 226, 0.4);
        }

        .send-button:active {
            transform: translateY(0);
        }

        .typing-indicator {
            display: none;
            align-self: flex-start;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 18px;
            border-bottom-left-radius: 5px;
            margin-bottom: 15px;
        }

        .typing-dots {
            display: flex;
            gap: 5px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--secondary-color);
            animation: typingAnimation 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) {
            animation-delay: 0s;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typingAnimation {

            0%,
            60%,
            100% {
                transform: translateY(0);
            }

            30% {
                transform: translateY(-10px);
            }
        }

        .floating-elements {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .floating-element {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, var(--primary-color), transparent);
            opacity: 0.1;
            animation: float 20s infinite linear;
        }

        @keyframes float {
            0% {
                transform: translate(0, 0) rotate(0deg);
            }

            25% {
                transform: translate(100px, 100px) rotate(90deg);
            }

            50% {
                transform: translate(0, 200px) rotate(180deg);
            }

            75% {
                transform: translate(-100px, 100px) rotate(270deg);
            }

            100% {
                transform: translate(0, 0) rotate(360deg);
            }
        }

        @media (max-width: 768px) {
            .message {
                max-width: 90%;
            }
        }
    </style>
</head>

<body>
    <div class="floating-elements" id="floatingElements"></div>

    <div class="container">
        <header>
            <div class="logo">
                <div class="logo-icon">ðŸ§š</div>
                <h1>Mythical Dreamscape AI</h1>
            </div>
            <div class="model-selector">
                <label for="modelDropdown">Model:</label>
                <select class="model-dropdown" id="modelDropdown">
                    <option value="">Loading models...</option>
                </select>
            </div>
        </header>

        <div class="chat-area">
            <div class="chat-messages" id="chatMessages">
                <div class="message ai-message">
                    Welcome to the Mythical Dreamscape AI! I'm here to assist you with any questions or thoughts you
                    might have.
                </div>
            </div>

            <div class="typing-indicator" id="typingIndicator">
                <div class="typing-dots">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            </div>

            <div class="chat-input-container">
                <textarea class="chat-input" id="chatInput" placeholder="Type your message here..." rows="1"></textarea>
                <button class="send-button" id="sendButton">
                    Send <span>âž¤</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // Create floating background elements
        const floatingElements = document.getElementById('floatingElements');
        for (let i = 0; i < 15; i++) {
            const element = document.createElement('div');
            element.classList.add('floating-element');
            const size = Math.random() * 100 + 50;
            element.style.width = `${size}px`;
            element.style.height = `${size}px`;
            element.style.left = `${Math.random() * 100}%`;
            element.style.top = `${Math.random() * 100}%`;
            element.style.animationDuration = `${Math.random() * 30 + 20}s`;
            floatingElements.appendChild(element);
        }

        // DOM elements
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.getElementById('sendButton');
        const typingIndicator = document.getElementById('typingIndicator');
        const modelDropdown = document.getElementById('modelDropdown');

        // Application state
        let currentModel = null;
        let models = [];
        let dataset = [];
        function generateFromPatterns(input, examples) {
            console.log("Generating from patterns with", examples.length, "examples");

            // Extract response patterns from similar examples
            const responses = examples.map(e => e.response);

            // Analyze openings
            const commonOpenings = responses.map(r => {
                const firstSentence = r.split(/[.!?]+/)[0];
                return firstSentence.split(' ').slice(0, 4).join(' ');
            });

            // Analyze themes
            const commonThemes = responses.map(r =>
                r.includes('magic') || r.includes('dream') || r.includes('realm') ? 'mythical' :
                    r.includes('feel') || r.includes('emotion') || r.includes('soul') ? 'emotional' :
                        'conversational'
            );

            // Choose patterns
            const randomOpening = commonOpenings[Math.floor(Math.random() * commonOpenings.length)];
            const theme = commonThemes[Math.floor(Math.random() * commonThemes.length)];

            console.log("Using opening:", randomOpening, "Theme:", theme);

            return craftNewResponse(input, randomOpening, theme);
        }

        // Load models from data.json
        async function loadModels() {
            try {
                const response = await fetch('data.json');
                const data = await response.json();
                models = data.models;

                // Populate model dropdown
                modelDropdown.innerHTML = '';
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.name;
                    option.textContent = model.name;
                    modelDropdown.appendChild(option);
                });

                // Auto-select first model
                if (models.length > 0) {
                    modelDropdown.value = models[0].name;
                    loadSelectedModel();
                }

            } catch (error) {
                console.error('Error loading models:', error);
                addMessage('Error loading models. Please check if data.json exists.', 'ai');
                modelDropdown.innerHTML = '<option value="">Error loading models</option>';
            }
        }


        function craftNewResponse(input, opening, theme, examples) {
            try {
                console.log("craftNewResponse called with", examples.length, "examples");

                if (!examples || examples.length === 0) {
                    return "The patterns are unclear. What shall we explore?";
                }

                const allResponses = examples.map(e => e.response);

                const learnedStyle = {
                    commonOpenings: allResponses.map(r => {
                        const firstSentence = r.split(/[.!?]+/)[0];
                        return firstSentence.split(' ').slice(0, 3).join(' ');
                    }).filter(opening => opening && opening.length > 0),

                    commonEndings: allResponses.map(r => {
                        const sentences = r.split(/[.!?]+/).filter(s => s.trim());
                        const lastSentence = sentences[sentences.length - 1] || '';
                        return lastSentence.split(' ').slice(-3).join(' ');
                    }).filter(ending => ending && ending.length > 0),

                    uniqueVocabulary: [...new Set(allResponses.flatMap(r => r.split(' ')))].filter(w => w && w.length > 2)
                };

                // Safety checks
                if (learnedStyle.commonOpenings.length === 0) learnedStyle.commonOpenings = ["I sense"];
                if (learnedStyle.commonEndings.length === 0) learnedStyle.commonEndings = ["shall we continue?"];
                if (learnedStyle.uniqueVocabulary.length === 0) learnedStyle.uniqueVocabulary = ["conversation", "explore", "wonder"];

                // RENAME THIS VARIABLE - it was conflicting with the parameter
                const chosenOpening = learnedStyle.commonOpenings[Math.floor(Math.random() * learnedStyle.commonOpenings.length)];
                let response = chosenOpening;

                // Add 2-4 random words from the dataset's vocabulary
                const wordCount = 2 + Math.floor(Math.random() * 3);
                for (let i = 0; i < wordCount; i++) {
                    const randomWord = learnedStyle.uniqueVocabulary[Math.floor(Math.random() * learnedStyle.uniqueVocabulary.length)];
                    response += " " + randomWord;
                }

                // Add ending
                const chosenEnding = learnedStyle.commonEndings[Math.floor(Math.random() * learnedStyle.commonEndings.length)];
                response += ". " + chosenEnding;

                return response;

            } catch (error) {
                console.error("Error in craftNewResponse:", error);
                return "The dreamscape shifts unexpectedly. Shall we begin anew?";
            }
        }
        // Load the selected model
        function loadSelectedModel() {
            const selectedModelName = modelDropdown.value;
            if (!selectedModelName) return;

            currentModel = models.find(m => m.name === selectedModelName);
            dataset = currentModel.dataset || [];

            // Clear chat and show model loaded message
            chatMessages.innerHTML = '';
            addMessage(`Model "${currentModel.name}" loaded successfully. How can I assist you today?`, 'ai');
        }

        // Add a message to the chat
        function addMessage(text, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message');
            messageDiv.classList.add(sender === 'user' ? 'user-message' : 'ai-message');
            messageDiv.textContent = text;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Show typing indicator
        function showTypingIndicator() {
            typingIndicator.style.display = 'block';
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Hide typing indicator
        function hideTypingIndicator() {
            typingIndicator.style.display = 'none';
        }

        // Calculate similarity between two strings
        function calculateSimilarity(str1, str2) {
            const words1 = new Set(str1.toLowerCase().split(/\s+/));
            const words2 = new Set(str2.toLowerCase().split(/\s+/));

            const intersection = new Set([...words1].filter(x => words2.has(x)));
            const union = new Set([...words1, ...words2]);

            return intersection.size / union.size;
        }

        function generateAIResponse(input) {
            console.log("=== NEW INPUT:", input);
            const inputLower = input.toLowerCase().trim();

            // 1. Exact match
            const exactMatch = dataset.find(example =>
                example.input.toLowerCase().trim() === inputLower
            );
            if (exactMatch) {
                console.log("EXACT MATCH USED");
                return exactMatch.response;
            }

            // 2. Similarity search
            const similarities = dataset.map(example => ({
                example,
                similarity: calculateSimilarity(inputLower, example.input.toLowerCase())
            }));

            similarities.sort((a, b) => b.similarity - a.similarity);

            // Use the top similarity score but require at least some relevance
            const topSimilarity = similarities[0]?.similarity || 0;
            const topExamples = similarities.slice(0, 5).filter(item =>
                item.similarity > Math.max(0.08, topSimilarity * 0.8)
            );

            console.log("Top examples found:", topExamples.length);
            console.log("Best similarity:", topSimilarity);

            // 3. Pattern generation
            if (topExamples.length > 0) {
                console.log("ATTEMPTING PATTERN GENERATION");
                const generated = generateFromPatterns(input, topExamples.map(t => t.example));
                console.log("Generated response:", generated);
                return generated;
            }

            // 4. Fallback
            console.log("FALLING BACK TO GENERIC");
            const randomExample = dataset[Math.floor(Math.random() * dataset.length)];
            return adaptResponse(randomExample.response, input);
        }

        // Analyze response patterns from example responses
        function analyzeResponsePatterns(responses) {
            const patterns = {
                greetings: [],
                questions: [],
                statements: [],
                emotions: [],
                structures: []
            };

            responses.forEach(response => {
                // Check for greeting patterns
                if (response.match(/\b(hi|hello|hey|greetings|welcome)\b/i)) {
                    patterns.greetings.push(response);
                }

                // Check for question patterns
                if (response.includes('?') || response.match(/\b(what|how|why|when|where|who)\b/i)) {
                    patterns.questions.push(response);
                }

                // Check for emotional content
                if (response.match(/\b(great|good|nice|wonderful|amazing|happy|excited|sorry|sad)\b/i)) {
                    patterns.emotions.push(response);
                }

                // Analyze sentence structure
                const sentences = response.split(/[.!?]+/).filter(s => s.trim().length > 0);
                patterns.structures.push({
                    sentenceCount: sentences.length,
                    avgLength: response.length / Math.max(sentences.length, 1),
                    hasQuestions: response.includes('?')
                });
            });

            return patterns;
        }

        // Generate a response based on patterns and input
        function generateResponseFromPatterns(input, patterns) {
            const inputLower = input.toLowerCase();

            // Determine response type based on input
            let responseType = 'statement';
            if (inputLower.match(/\b(hi|hello|hey|greetings)\b/)) {
                responseType = 'greeting';
            } else if (inputLower.includes('?')) {
                responseType = 'answer';
            } else if (inputLower.match(/\b(how are you|how do you feel)\b/)) {
                responseType = 'emotional';
            }

            // Build response based on type
            let response = '';

            switch (responseType) {
                case 'greeting':
                    response = generateGreetingResponse(patterns);
                    break;
                case 'answer':
                    response = generateAnswerResponse(input, patterns);
                    break;
                case 'emotional':
                    response = generateEmotionalResponse(patterns);
                    break;
                default:
                    response = generateStatementResponse(input, patterns);
            }

            // Ensure the response is not empty
            if (!response || response.trim().length === 0) {
                response = generateFallbackResponse(input);
            }

            return response;
        }

        // Generate a greeting response
        function generateGreetingResponse(patterns) {
            const greetings = [
                "Hello there! How can I assist you today?",
                "Hi! It's great to connect with you. What's on your mind?",
                "Greetings! I'm here and ready to help. What would you like to talk about?",
                "Hey! Thanks for reaching out. How can I be of service?"
            ];

            // If we have greeting patterns, try to create a more personalized greeting
            if (patterns.greetings.length > 0) {
                const randomGreeting = patterns.greetings[Math.floor(Math.random() * patterns.greetings.length)];
                const words = randomGreeting.split(' ');

                // Extract the greeting part (usually first 2-4 words)
                const greetingPart = words.slice(0, Math.min(4, words.length)).join(' ');

                // Create variations
                const variations = [
                    `${greetingPart}! What brings you here today?`,
                    `${greetingPart}. How can I help you?`,
                    `${greetingPart}. It's wonderful to connect with you.`
                ];

                return variations[Math.floor(Math.random() * variations.length)];
            }

            return greetings[Math.floor(Math.random() * greetings.length)];
        }

        // Generate an answer to a question
        function generateAnswerResponse(input, patterns) {
            // Extract the question word
            const questionWords = ['what', 'how', 'why', 'when', 'where', 'who'];
            let questionWord = 'what';

            for (const word of questionWords) {
                if (input.toLowerCase().includes(word)) {
                    questionWord = word;
                    break;
                }
            }

            // Create a thoughtful response based on the question type
            const responses = {
                what: [
                    "That's an interesting question. From my understanding, ",
                    "I've been thinking about that too. In my perspective, ",
                    "That's a great question. Based on what I know, "
                ],
                how: [
                    "Let me share my thoughts on how that works. ",
                    "The process typically involves ",
                    "From my experience, here's how it usually goes: "
                ],
                why: [
                    "There are several reasons for that. Primarily, ",
                    "That's because ",
                    "The main reason is "
                ],
                when: [
                    "Timing can vary, but generally ",
                    "Based on patterns I've observed, ",
                    "It typically happens when "
                ],
                where: [
                    "Location can be important here. Usually, ",
                    "Based on my knowledge, ",
                    "That tends to occur where "
                ],
                who: [
                    "There are several perspectives on who might be involved. ",
                    "Based on my understanding, ",
                    "That would typically involve "
                ]
            };

            const intro = responses[questionWord][Math.floor(Math.random() * responses[questionWord].length)];

            // Add a thoughtful continuation
            const continuations = [
                "it relates to the broader context of our conversation.",
                "there are multiple factors to consider in situations like this.",
                "your question touches on an important aspect worth exploring further."
            ];

            return intro + continuations[Math.floor(Math.random() * continuations.length)];
        }

        // Generate an emotional response
        function generateEmotionalResponse(patterns) {
            const emotionalStates = [
                "I'm functioning well, thank you for asking! How are you feeling today?",
                "I'm doing great! Always ready for a good conversation. How about you?",
                "I'm in a positive state, ready to assist. How's everything with you?",
                "I'm feeling quite good today! Thanks for checking in. How are you?"
            ];

            return emotionalStates[Math.floor(Math.random() * emotionalStates.length)];
        }

        // Generate a statement response
        function generateStatementResponse(input, patterns) {
            // Create a response that acknowledges the input and continues the conversation
            const acknowledgments = [
                "I see what you're saying about ",
                "That's an interesting point about ",
                "I understand your perspective on ",
                "Thanks for sharing that about "
            ];

            const acknowledgment = acknowledgments[Math.floor(Math.random() * acknowledgments.length)];

            // Extract key topic from input (simple approach - take first few words)
            const words = input.split(' ').slice(0, 3).join(' ');

            // Continue the thought
            const continuations = [
                ". Could you tell me more about that?",
                ". What are your thoughts on this?",
                ". How does that relate to your experiences?",
                ". I'd love to hear more about your perspective."
            ];

            const continuation = continuations[Math.floor(Math.random() * continuations.length)];

            return acknowledgment + words + continuation;
        }

        // Generate a fallback response
        function generateFallbackResponse(input) {
            const fallbacks = [
                "That's an interesting point. Could you tell me more about that?",
                "I'm not sure I fully understand. Could you rephrase that?",
                "That's something worth exploring further. What are your thoughts on it?",
                "I see what you're saying. Let me think about that for a moment.",
                "That's a fascinating perspective. How did you come to that conclusion?"
            ];

            return fallbacks[Math.floor(Math.random() * fallbacks.length)];
        }

        // Handle sending a message
        function sendMessage() {
            const message = chatInput.value.trim();
            if (!message) return;

            // Add user message
            addMessage(message, 'user');
            chatInput.value = '';

            // Show typing indicator
            showTypingIndicator();

            // Generate AI response after a delay to simulate thinking
            setTimeout(() => {
                hideTypingIndicator();

                if (!currentModel) {
                    addMessage("Please select a model first.", 'ai');
                    return;
                }

                const response = generateAIResponse(message);
                addMessage(response, 'ai');
            }, 1000 + Math.random() * 1000);
        }

        // Event listeners
        sendButton.addEventListener('click', sendMessage);

        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Model dropdown change
        modelDropdown.addEventListener('change', loadSelectedModel);

        // Auto-resize textarea
        chatInput.addEventListener('input', function () {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });

        // Initialize the application
        loadModels();
    </script>
</body>

</html>
